import { invoke } from "@tauri-apps/api/core";

// ---------- Types that match sources.json ----------

type ImageSource = {
  id: string;
  name: string;

  base_path?: string;            // e.g. "GOES18/ABI/FD/GEOCOLOR"
  image_url?: string;            // legacy/manual fallback, optional

  satellite?: string;
  sector?: string;
  product?: string;

  default_refresh_minutes?: number;
  attribution?: string;
  region?: string;
  resolution_hint_high?: string;
  resolution_hint_low?: string;

  favorite?: boolean;
};

type SourcesConfig = {
  version: number;
  sources: ImageSource[];
};

// ---------- Globals & helpers ----------

const NOAA_BASE = "https://cdn.star.nesdis.noaa.gov/";

let currentConfig: SourcesConfig | null = null;
let refreshTimerId: number | null = null;

function byId<T extends HTMLElement>(id: string): T {
  const el = document.getElementById(id);
  if (!el) {
    throw new Error(`Missing element with id="${id}"`);
  }
  return el as T;
}

function setText(id: string, text: string) {
  const el = document.getElementById(id);
  if (el) el.textContent = text;
}

function makeSourceLabel(src: ImageSource): string {
  const extraParts: string[] = [];
  if (src.region) extraParts.push(src.region);
  if (src.resolution_hint_high) extraParts.push(src.resolution_hint_high);

  return extraParts.length > 0
    ? `${src.name} (${extraParts.join(" ‚Ä¢ ")})`
    : src.name;
}

function getSelectedSource(): ImageSource | undefined {
  if (!currentConfig) return;
  const select = document.getElementById("source") as HTMLSelectElement | null;
  if (!select) return;
  return currentConfig.sources.find((s) => s.id === select.value);
}

function getResolutionSelection(): "high" | "low" {
  const checked = document.querySelector<HTMLInputElement>(
    'input[name="resolution"]:checked',
  );
  return checked?.value === "low" ? "low" : "high";
}

function buildPreviewUrl(src: ImageSource): string {
  // Preview always uses thumbnail when base_path is available
  if (src.base_path) {
    return `${NOAA_BASE}${src.base_path}/thumbnail.jpg`;
  }
  // Fallback: if only image_url exists, use that
  if (src.image_url) {
    return src.image_url;
  }
  throw new Error(`Source "${src.id}" has neither base_path nor image_url`);
}

function buildWallpaperUrl(src: ImageSource, quality: "high" | "low"): string {
  if (src.base_path) {
    if (quality === "high") {
      // High-res ‚Üí latest.jpg
      return `${NOAA_BASE}${src.base_path}/latest.jpg`;
    } else {
      // Low-res ‚Üí thumbnail.jpg
      return `${NOAA_BASE}${src.base_path}/thumbnail.jpg`;
    }
  }

  // Fallback for legacy entries that only specify image_url
  if (src.image_url) {
    return src.image_url;
  }

  throw new Error(`Source "${src.id}" has neither base_path nor image_url`);
}

async function tagSourceFreshness(src: ImageSource) {
  const select = document.getElementById("source") as HTMLSelectElement | null;
  if (!select) return;

  const opt = select.querySelector(
    `option[value="${src.id}"]`,
  ) as HTMLOptionElement | null;
  if (!opt) return;

  const baseLabel =
    (opt as any).dataset.label || opt.textContent || src.name || src.id;

  // Decide which URL to test for freshness:
  // use the high-res one (latest.jpg) as the canonical "age"
  let testUrl: string;
  try {
    testUrl = buildWallpaperUrl(src, "high");
  } catch {
    // If something is wrong with the config, mark as unknown and bail
    opt.textContent = `‚ùî ${baseLabel}`;
    // color isn't super reliable on <option>, but we can set it
    opt.style.color = "";
    return;
  }

  let symbol = "üü°";
  let color = "";

  try {
    const resp = await fetch(testUrl, { method: "HEAD" });

    if (!resp.ok) {
      symbol = "üî¥";
    } else {
      const lastModified = resp.headers.get("Last-Modified");
      if (!lastModified) {
        symbol = "üî¥";
      } else {
        const lmDate = new Date(lastModified);
        if (isNaN(lmDate.getTime())) {
          symbol = "üî¥";
        } else {
          const ageHours =
            (Date.now() - lmDate.getTime()) / (1000 * 60 * 60);

          if (ageHours > 12) {
            symbol = "üî¥";   // stale
          } else {
            symbol = "üü¢";   // fresh
          }
        }
      }
    }
  } catch (e) {
    console.error("Failed to check freshness for", src.id, e);
    symbol = "üü°";
  }

  // Update option text and (best-effort) color
  opt.textContent = `${symbol} ${baseLabel}`;
  opt.style.color = color;
}

type AreaId = "west" | "east";
type CoverageId = "global" | "continental" | "regional";

const AREA_LABELS: Record<AreaId, string> = {
  west: "Western side (Pacific / Alaska / Hawaii / Western Americas)",
  east: "Eastern side (Atlantic / Caribbean / Eastern Americas)",
};

const COVERAGE_LABELS: Record<CoverageId, string> = {
  global: "Full Disk (whole hemisphere)",
  continental: "U.S. & nearby",
  regional: "Regional views",
};

// area -> coverage -> list of sources
let groupedSources: Record<AreaId, Record<CoverageId, ImageSource[]>> = {
  west: { global: [], continental: [], regional: [] },
  east: { global: [], continental: [], regional: [] },
};

function classifyArea(src: ImageSource): AreaId {
  // Default: GOES18 ‚Üí west, everything else ‚Üí east
  const sat = (src.satellite || "").toUpperCase();
  if (sat.includes("18")) return "west";
  if (sat.includes("19")) return "east";
  // If unknown, guess east
  return "east";
}

function classifyCoverage(src: ImageSource): CoverageId {
  const sector = (src.sector || "").toUpperCase();
  const region = (src.region || "").toLowerCase();

  if (sector === "FD") {
    return "global";
  }

  if (
    sector === "CONUS" ||
    region.includes("conus") ||
    region.includes("u.s.") ||
    region.includes(" us ") ||
    region.includes("america")
  ) {
    return "continental";
  }

  return "regional";
}

function groupSourcesForSelector(sources: ImageSource[]) {
  // reset
  groupedSources = {
    west: { global: [], continental: [], regional: [] },
    east: { global: [], continental: [], regional: [] },
  };

  for (const src of sources) {
    const area = classifyArea(src);
    const cov = classifyCoverage(src);
    groupedSources[area][cov].push(src);
  }

  // Optional: sort regions alphabetically by name for nicer UI
  (["west", "east"] as AreaId[]).forEach((area) => {
    (["global", "continental", "regional"] as CoverageId[]).forEach((cov) => {
      groupedSources[area][cov].sort((a, b) =>
        (a.region || a.name).localeCompare(b.region || b.name),
      );
    });
  });
}

// ---------- Config loading ----------

async function loadSourcesConfig() {
  try {
    const cfg = await invoke<SourcesConfig>("get_sources_config");
    currentConfig = cfg;

    // Multi-step selector should see ALL sources
    groupSourcesForSelector(cfg.sources);

    // Build favorites list for the main dropdown
    const allSources = cfg.sources;
    const favorites = allSources.filter((s) => s.favorite);
    const dropdownSources = favorites.length ? favorites : allSources;

    const select = byId<HTMLSelectElement>("source");
    select.innerHTML = "";

    const placeholder = document.createElement("option");
    placeholder.value = "";
    placeholder.disabled = true;
    placeholder.selected = true;
    placeholder.textContent = "Select source...";
    select.appendChild(placeholder);

    // Populate dropdown with favorites (or all, if none marked favorite)
    for (const src of dropdownSources) {
      const opt = document.createElement("option");
      opt.value = src.id;

      const baseLabel = makeSourceLabel(src);
      opt.textContent = baseLabel;
      (opt as any).dataset.label = baseLabel; // remember bare label for later

      select.appendChild(opt);

      // Kick off async freshness tagging for this source (fire-and-forget)
      tagSourceFreshness(src).catch((e) =>
        console.error("Failed to tag source freshness", src.id, e),
      );
    }
  } catch (e) {
    console.error("Failed to load sources config", e);
    setText("download-status", "Failed to load sources config. Check config file.");
  }
}



async function updateImageFreshness(url: string) {
  const ageDiv = document.getElementById("image-age") as HTMLDivElement | null;
  if (!ageDiv) return;

  try {
    // HEAD is lighter than GET; NOAA should expose Last-Modified as a simple header
    const resp = await fetch(url, { method: "HEAD" });

    if (!resp.ok) {
      ageDiv.textContent = `Image metadata not available (HTTP ${resp.status}).`;
      return;
    }

    const lastModified = resp.headers.get("Last-Modified");
    if (!lastModified) {
      ageDiv.textContent = "Image timestamp not available.";
      return;
    }

    const lmDate = new Date(lastModified);
    if (isNaN(lmDate.getTime())) {
      ageDiv.textContent = `Image timestamp could not be parsed: ${lastModified}`;
      return;
    }

    const now = Date.now();
    const ageMs = now - lmDate.getTime();
    const ageHours = ageMs / (1000 * 60 * 60);

    const wholeHours = Math.floor(ageHours);
    const minutes = Math.round((ageHours - wholeHours) * 60);

    const ageText =
      wholeHours > 0 ? `${wholeHours}h ${minutes}m ago` : `${minutes}m ago`;

    const warning =
      ageHours > 12
        ? "‚ö†Ô∏è"
        : "‚úì";

    const lmStr = lmDate.toUTCString();

    ageDiv.textContent = `Last updated: ${lmStr} (${ageText}). ${warning}`;
    if (ageHours > 12) {
      ageDiv.style.color = "red";
    } else {
      ageDiv.style.color = "green";
    }
  } catch (err) {
    console.error("Failed to fetch image age", err);
    ageDiv.textContent = "Could not determine image age.";
    ageDiv.style.color = "red";
  }
}

// ---------- Wiring UI ----------


// 1) Preview: show thumbnail and update URL box according to hi/low
function wireSourceAutoPreview() {
  const select = document.getElementById("source") as HTMLSelectElement | null;
  if (!select) return;

  select.addEventListener("change", () => {
    const src = getSelectedSource();
    if (!src) return;

    const img = document.getElementById("preview") as HTMLImageElement | null;
    if (!img) return;

    // Thumbnail for preview
    const previewUrl = buildPreviewUrl(src);
    img.src = previewUrl;

    // High/low choice for wallpaper URL
    const quality = getResolutionSelection();
    const wallpaperUrl = buildWallpaperUrl(src, quality);

    const urlInput = document.getElementById(
      "wallpaper-url",
    ) as HTMLInputElement | null;
    if (urlInput) {
      urlInput.value = wallpaperUrl;
    }

    // Update age indicator based on wallpaper URL
    updateImageFreshness(wallpaperUrl);
  });
}

// 2) Optional: Set wallpaper from local path (if controls exist)
function wireSetWallpaperFromPath() {
  const button = document.getElementById("set-wallpaper") as HTMLButtonElement | null;
  const pathInput = document.getElementById(
    "wallpaper-path",
  ) as HTMLInputElement | null;

  // If those inputs aren't in the HTML, just silently skip
  if (!button || !pathInput) return;

  button.addEventListener("click", async () => {
    const path = pathInput.value.trim();
    if (!path) {
      alert("Enter a local image path first.");
      return;
    }

    try {
      await invoke("set_wallpaper", { path });
      alert(`Wallpaper set from local file:\n${path}`);
    } catch (e: any) {
      console.error(e);
      alert(`Failed to set wallpaper: ${String(e)}`);
    }
  });
}
function wireMultiStepSelector() {
  const areaSelect = document.getElementById(
    "area-select",
  ) as HTMLSelectElement | null;
  const coverageSelect = document.getElementById(
    "coverage-select",
  ) as HTMLSelectElement | null;
  const regionSelect = document.getElementById(
    "region-select",
  ) as HTMLSelectElement | null;

  const mainSourceSelect = document.getElementById(
    "source",
  ) as HTMLSelectElement | null;

  if (!areaSelect || !coverageSelect || !regionSelect || !mainSourceSelect) {
    return;
  }

  // --- populate AREA options ---
  areaSelect.innerHTML = '<option value="">Select area...</option>';
  (["west", "east"] as AreaId[]).forEach((areaId) => {
    // Only show areas that have at least one source
    const areaGroups = groupedSources[areaId];
    const hasAny =
      areaGroups.global.length ||
      areaGroups.continental.length ||
      areaGroups.regional.length;
    if (!hasAny) return;

    const opt = document.createElement("option");
    opt.value = areaId;
    opt.textContent = AREA_LABELS[areaId];
    areaSelect.appendChild(opt);
  });

  coverageSelect.innerHTML = '<option value="">Select coverage...</option>';
  coverageSelect.disabled = true;
  regionSelect.innerHTML = '<option value="">Select region...</option>';
  regionSelect.disabled = true;

  // --- area change: populate coverage ---
  areaSelect.addEventListener("change", () => {
    const area = areaSelect.value as AreaId | "";
    coverageSelect.innerHTML = '<option value="">Select coverage...</option>';
    regionSelect.innerHTML = '<option value="">Select region...</option>';
    regionSelect.disabled = true;

    if (!area) {
      coverageSelect.disabled = true;
      return;
    }

    const areaGroups = groupedSources[area];
    (["global", "continental", "regional"] as CoverageId[]).forEach((covId) => {
      const list = areaGroups[covId];
      if (!list.length) return;
      const opt = document.createElement("option");
      opt.value = covId;
      opt.textContent = COVERAGE_LABELS[covId];
      coverageSelect.appendChild(opt);
    });

    coverageSelect.disabled = false;
  });

  // --- coverage change: populate regions ---
  coverageSelect.addEventListener("change", () => {
    const area = areaSelect.value as AreaId | "";
    const cov = coverageSelect.value as CoverageId | "";
    regionSelect.innerHTML = '<option value="">Select region...</option>';

    if (!area || !cov) {
      regionSelect.disabled = true;
      return;
    }

    const list = groupedSources[area][cov];
    for (const src of list) {
      const opt = document.createElement("option");
      opt.value = src.id;
      opt.textContent = src.region || src.name;
      regionSelect.appendChild(opt);
    }

    regionSelect.disabled = !list.length;
  });

  // --- region change: pick source + trigger your existing logic ---
  regionSelect.addEventListener("change", () => {
    const sourceId = regionSelect.value;
    if (!sourceId) return;

    // Set the main favorites dropdown to this source
    mainSourceSelect.value = sourceId;

    // Trigger your existing 'change' handler on #source
    const evt = new Event("change", { bubbles: true });
    mainSourceSelect.dispatchEvent(evt);
  });
}

// 3) Optional test button: still uses whatever test URL you like
function wireTestWallpaperDownload() {
  const testBtn = document.getElementById(
    "test-wallpaper-download",
  ) as HTMLButtonElement | null;
  if (!testBtn) return;

  testBtn.addEventListener("click", async () => {
    const statusId = "test-wallpaper-status";
    const testUrl =
      "https://cdn.star.nesdis.noaa.gov/GOES18/ABI/FD/GEOCOLOR/latest.jpg";

    setText(statusId, "Downloading test image and setting wallpaper...");

    try {
      const path = await invoke<string>("download_image_and_set_wallpaper", {
        url: testUrl,
      });
      setText(
        statusId,
        `Success! Test wallpaper set from: ${path}`,
      );
    } catch (e: any) {
      console.error(e);
      setText(statusId, `Failed: ${String(e)}`);
    }
  });
}

// 4) Download URL ‚Üí Set as Wallpaper
function wireDownloadSetWallpaper() {
  const btn = document.getElementById(
    "download-set-wallpaper",
  ) as HTMLButtonElement | null;
  const urlInput = document.getElementById(
    "wallpaper-url",
  ) as HTMLInputElement | null;

  if (!btn || !urlInput) return;

  btn.addEventListener("click", async () => {
    const statusId = "download-status";
    let url = urlInput.value.trim();

    // If no manual URL, use selected source + hi/low
    if (!url) {
      const src = getSelectedSource();
      if (!src) {
        setText(statusId, "Please enter an image URL or select a source.");
        return;
      }
      const quality = getResolutionSelection();
      url = buildWallpaperUrl(src, quality);
      urlInput.value = url; // mirror into textbox
    }

    setText(statusId, "Downloading image and setting wallpaper...");

    try {
      const path = await invoke<string>("download_image_and_set_wallpaper", {
        url,
      });
      setText(statusId, `Success! Wallpaper set from: ${path}`);
    } catch (e: any) {
      console.error(e);
      setText(statusId, `Failed: ${String(e)}`);
    }
  });
}

// 5) Auto refresh: uses selected source + hi/low toggle
let isAutoRefreshing = false;

function wireAutoRefreshToggle() {
  const btn = document.getElementById(
    "auto-refresh-toggle",
  ) as HTMLButtonElement | null;
  const minutesInput = document.getElementById(
    "refresh-minutes",
  ) as HTMLInputElement | null;
  if (!btn || !minutesInput) return;

  const statusId = "refresh-status";

  const updateButtonLabel = () => {
    btn.textContent = isAutoRefreshing
      ? "Turn auto-update off"
      : "Turn auto-update on";
  };

  const stopRefresh = () => {
    if (refreshTimerId !== null) {
      window.clearInterval(refreshTimerId);
      refreshTimerId = null;
    }
    isAutoRefreshing = false;
    updateButtonLabel();
    setText(statusId, "Auto-update is off.");
  };

  const startRefresh = () => {
    const src = getSelectedSource();
    if (!src) {
      alert("Select a source before enabling auto-update.");
      return;
    }

    const quality = getResolutionSelection(); // hi/low at time of enabling

    const minutesRaw = parseFloat(minutesInput.value || "0");
    const minutes =
      !isNaN(minutesRaw) && minutesRaw > 0
        ? minutesRaw
        : src.default_refresh_minutes || 10;
    const intervalMs = minutes * 60 * 1000;

    if (refreshTimerId !== null) {
      window.clearInterval(refreshTimerId);
    }

    const runOnce = async () => {
      try {
        const url = buildWallpaperUrl(src, quality);
        const path = await invoke<string>("download_image_and_set_wallpaper", {
          url,
        });
        setText(
          statusId,
          `Auto-update (${quality}) every ${minutes} min. Last: ${path}`,
        );
        // keep your age indicator in sync
        updateImageFreshness(url);
      } catch (e: any) {
        console.error(e);
        setText(statusId, `Auto-update failed: ${String(e)}`);
      }
    };

    runOnce();
    refreshTimerId = window.setInterval(runOnce, intervalMs);
    isAutoRefreshing = true;
    updateButtonLabel();
  };

  updateButtonLabel();

  btn.addEventListener("click", () => {
    if (isAutoRefreshing) {
      stopRefresh();
    } else {
      startRefresh();
    }
  });
}

function wireStartupToggle() {
  const checkbox = document.getElementById(
    "startup-checkbox",
  ) as HTMLInputElement | null;
  const status = document.getElementById(
    "startup-status",
  ) as HTMLDivElement | null;

  if (!checkbox || !status) return;

  checkbox.addEventListener("change", async () => {
    const enabled = checkbox.checked;
    status.textContent = enabled
      ? "Enabling run on startup..."
      : "Disabling run on startup...";

    try {
      await invoke("set_run_on_startup", { enabled });
      status.textContent = enabled
        ? "Will run when Windows starts."
        : "Won't run automatically on startup.";
    } catch (e: any) {
      console.error(e);
      status.textContent = `Failed to update startup setting: ${String(e)}`;
    }
  });
}


// ---------- Bootstrap ----------

async function bootstrap() {
  await loadSourcesConfig();
  wireStartupToggle();

  wireSourceAutoPreview();
  wireMultiStepSelector(); 
  wireSetWallpaperFromPath();
  wireTestWallpaperDownload();
  wireDownloadSetWallpaper();
  wireAutoRefreshToggle();
}

bootstrap().catch((e) => console.error("Bootstrap error:", e));
